import os
import glob
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.transform import Rotation
from render import util

def load_points(filename):
    """Loads the point cloud generated by Colmap from a file.

    Args:
        filename: path to the file where the point clod description is stored.

    Returns:
        A tuple containing the array of points (x, y, z, r, g, b) and the mapping 
        (dictionary) from the point ID to the row where it's located in the array. 
    """

    file = open(filename)
    points = np.array([])
    mapping = {}
    i = 0
    for line in file:
        if not '#' in line:
            info = line.split(' ')
            id = int(info[0])
            x = float(info[1])
            y = float(info[2])
            z = float(info[3])
            red = float(info[4]) / 255.0
            green = float(info[5]) / 255.0
            blue = float(info[6]) / 255.0
            points = np.append(points, np.array([x, -y, -z, red, green, blue]))
            mapping[id] = i
            i += 1
    file.close()
    return (points.reshape((-1, 6)), mapping)

def load_cameras(filename, resolution):
    """Loads the camera information estimatd by Colmap.

    Args:
        filename: path to the file where the cameras description is stored.
        resolution: array containing the height (0) and width (1) of the images
        used for the estimation.

    Returns:
        A tuple containing a dictionary with the view matrices associated with 
        each image, the key points observed in each image, the positions of the 
        cameras and the look at directions of each camera.
    """

    description_file = open(filename)
    nex_is_list = False
    view_mtxs = {}
    view_points = {}
    camera_centers = {}
    look_ats = {}
    last_key = ""
    for line in description_file:
        if not '#' in line and not nex_is_list:
            units = line.split(" ")
            qw = float(units[1])
            qx = float(units[2])
            qy = float(units[3])
            qz = float(units[4])
            tx = float(units[5])
            ty = float(units[6])
            tz = float(units[7])
            rm = np.array(Rotation.from_quat([qx, -qy, -qz, qw]).as_matrix())
            tm = np.array([[tx], [-ty], [-tz]])
            mtx = np.hstack((rm, tm))
            mtx = np.vstack((mtx, np.zeros((1, 4))))
            mtx[3,3] = 1
            view_mtxs[units[9][:-1]] = mtx.astype(np.float32)
            camera_centers[units[9][:-1]] = -(np.transpose(rm)) @ tm
            look_ats[units[9][:-1]] = -np.transpose(rm) @ np.array([0, 0, 1]).reshape(3, 1)
            last_key = units[9][:-1]
            nex_is_list = True
        elif not '#' in line and nex_is_list:
            units = line.split(" ")
            for i in range(0, len(units), 3):
                px = float(units[i])
                py = resolution[0] - float(units[i + 1])
                pid = int(units[i + 2])
                if pid >= 0:
                    if not last_key in view_points.keys():
                        view_points[last_key] = np.array([])
                    view_points[last_key] = np.append(view_points[last_key], np.array([float(pid), px, py]))
            if last_key in view_points.keys():
                view_points[last_key] = np.reshape(view_points[last_key], (-1, 3))
            nex_is_list = False
    description_file.close()
    return (view_mtxs, view_points, camera_centers, look_ats)

def apply_bounding_box(bb, points, array_mapping, points_in_views, resolution, top=100, plot=False, save_interval=300):
    """Filters the points estimated in Colmap by applying a bounding box on the
    2D proyection of the key points in each image.  

    Args:
        bb: 2x2 array defining the lower left and the upper right corners.
        points: array storing the points of the cloud.
        array_mapping: dictionary relating the point ID with it's position in the
        array.
        points_in_views: dictionary of the key points seen in each image. 
        resolution: array containing the height (0) and width (1) of the images
        used for the estimation.
        top: number of most voted points that will form the solution (default 100).
        plot: do you want to plot the filtering? (Default Flase).
        save_interval: frequancy in which the filtering is plotted and stored 
        (default 300).

    Returns:
        A tuple containing the filtered point cloud and the weights (votes) that 
        each point recieved.
    """

    filtered_points = points
    filter_values = np.zeros(filtered_points.shape[0], dtype=np.float32)
    iters = 0
    for key in points_in_views:
        keypoints = points_in_views[key]
        hx = keypoints[:, 1] > np.tile(bb[0, 0], (keypoints.shape[0]))
        lx = keypoints[:, 1] < np.tile(bb[1, 0], (keypoints.shape[0]))
        inside_x = np.logical_and(hx, lx)
        hy = keypoints[:, 2] > np.tile(bb[0, 1], (keypoints.shape[0]))
        ly = keypoints[:, 2] < np.tile(bb[1, 1], (keypoints.shape[0]))
        inside_y = np.logical_and(hy, ly)
        keypoints = keypoints[np.logical_and(inside_x, inside_y)]

        visible_rows = np.array([], dtype=int)
        for i in range(0, keypoints.shape[0]):
            row = array_mapping[ int(keypoints[i, 0]) ]
            visible_rows = np.append(visible_rows, [row])
        filter_values[visible_rows] += 1

        if plot and iters % save_interval == 0:
            fig = plt.figure()
            fig.set_size_inches(resolution[1]/100, resolution[0]/100)
            fig.set_dpi(100)

            ax1 = fig.add_subplot()
            ax1.scatter(keypoints[:, 1], keypoints[:, 2], c=filtered_points[visible_rows, 3:6])
            ax1.set_xlabel("X")
            ax1.set_ylabel("Y")
            ax1.set_xlim([0, resolution[1]])
            ax1.set_ylim([0, resolution[0]])

            plt.savefig("filtering_{:s}".format(key))
            plt.close()
        
        iters += 1
    filtered_inds = np.argsort(-filter_values)[:min(top, filter_values.shape[0])]
    filter_values = filter_values[filtered_inds]
    filtered_points = filtered_points[filtered_inds]
    return (filtered_points, filter_values)

def relocate_view_matrix(origin, view_matrix):
    """Modifies the view matrix according to anew center of coodinates. 

    Args:
        origin: new origin for the system of coordinates.
        view_matrix: view matrix to modify.

    Returns:
        A new view matrix centered in the provided point.
    """
    rotM = np.eye(4,4)
    rotM[0:3, 0:3] = view_matrix[0:3, 0:3]
    trasM = np.eye(4,4)
    camera_center = -(np.transpose(view_matrix[0:3, 0:3])) @ view_matrix[0:3, 3].reshape(3, 1)
    trasM[0:3, 3] = -1 * (camera_center.reshape(3) - origin)
    view_matrix = rotM @ trasM
    return view_matrix

def find_sphere(P1, P2, P3, P4):
    """Given 4 points estimates the sphere that contains them. 

    Args:
        P1, P2, P3, P4: points in 3D space.

    Returns:
        A tuple containing the center of the sphere and its radius.
    """
    K1 = np.power(P1[0], 2) + np.power(P1[1], 2) + np.power(P1[2], 2)
    K2 = np.power(P2[0], 2) + np.power(P2[1], 2) + np.power(P2[2], 2)
    K3 = np.power(P3[0], 2) + np.power(P3[1], 2) + np.power(P3[2], 2)
    K4 = np.power(P4[0], 2) + np.power(P4[1], 2) + np.power(P4[2], 2)

    X1 = -2 * P1[0]
    Y1 = -2 * P1[1]
    Z1 = -2 * P1[2]

    X2 = -2 * P2[0]
    Y2 = -2 * P2[1]
    Z2 = -2 * P2[2]

    X3 = -2 * P3[0]
    Y3 = -2 * P3[1]
    Z3 = -2 * P3[2]

    X4 = -2 * P4[0]
    Y4 = -2 * P4[1]
    Z4 = -2 * P4[2]

    F = (Y1 - Y2)/(Y1 - Y3) if (Y1 - Y3) != 0.0 else 0.0
    G = (Y1 - Y2)/(Y1 - Y4) if (Y1 - Y4) != 0.0 else 0.0
    H = (Z1 - Z2 - F * Z1 + F * Z3)/(Z1 - Z2 - G * Z1 + G * Z4) if (Z1 - Z2 - G * Z1 + G * Z4) != 0.0 else 0.0

    cA = K1 - K2 - F * K1 + F * K3 - H * K1 + H * K2 + H * G * K1 - H * G * K4
    dA = X1 - X2 - F * X1 + F * X3 - H * X1 + H * X2 + H * G * X1 - H * G * X4
    a = - cA / dA if dA != 0 else 0.0

    cC = K1 - K2 - F * K1 + F * K3 + (X1 - X2 - F * X1 + F * X3) * a
    dC = Z1 - Z2 - F * Z1 + F * Z3
    c = - cC / dC if dC != 0 else 0.0

    cB = (K1 - K2) + (Z1 - Z2) * c + (X1 - X2) * a
    dB = Y1 - Y2
    b = - cB / dB if dB != 0 else 0.0

    d = - (K1 + Z1 * c + X1 * a + Y1 * b)
    r = np.sqrt(np.power(c, 2) + np.power(b, 2) + np.power(a, 2) - d)

    return (np.array([a, b, c]), r)

def filter_outliers(points, directions):
    mods = np.linalg.norm(points, axis=-1)
    avr_mod = np.mean(mods)
    outliers = points[mods > 2 * avr_mod]
    if outliers.shape[0] > 0:
        print("Colmap utils: Outliers found and removed: \n{}".format(outliers))
    else:
        print("Colmap utils: No outliers have been found.")
    points = points[mods <= 2 * avr_mod]
    directions = directions[mods <= 2 * avr_mod]
    return (points, directions)


def sphere_search(points, directions, reference_point=None, iterations=1000, generations=20, max_depth=50, alpha=0.6, exhaustive_search=False):
    """Searches the 4 points that best describe the sphere that characterizes a
    set of oriented points.

    Args:
        points: array describing a list of positions in 3D space.
        directions: direction towards which each point is oriented.
        reference_point: point in 3D that hints the position of the center (default None).
        iterations: maximum number of iterations (default 1000).
        generations: number of generated solutions per iteration (default 20).
        max_depth: maximum depth for the local exploration (default 50).
        alpha: parameter that controls the randomness of the algorithm. Zero is 
        completely greedy and one is completely random (default 0.6). 
        exhaustive_search: should the local exploration be exhaustive? (Default False).

    Returns:
        Center of the best sphere found.
    """

    np.random.seed(237)

    use_reference_point = not isinstance(reference_point, type(None))

    points, directions = filter_outliers(points, directions)
    directions = directions / np.tile(np.linalg.norm(directions, axis=-1), (1, directions.shape[1])).reshape(directions.shape)

    n_points = points.shape[0]
    dims = points.shape[1]
    gridA = np.reshape(np.tile(points, (1, n_points)), (n_points, n_points, dims))
    gridB = np.transpose(gridA, axes=(1, 0, 2))
    distances = np.linalg.norm(gridA - gridB, axis=-1)
    
    for i in np.random.randint(0, n_points, 3):
        for j in np.random.randint(0, n_points, 3):
            assert distances[i, j] == np.linalg.norm(points[i] - points[j])

    max_radius = 2.0 * np.max(distances)

    best_sol = np.zeros(dims)
    best_sol_inds = np.zeros(4)
    best_cost = np.Infinity
    indices = np.array(range(0, n_points))
    for _ in range(0, iterations):
        # -------------- Constructive phase -------------- #
        #print("Constructing...")
        for _ in range(0, generations):
            built_sol = np.random.randint(0, n_points, 1)
            for _ in range(1, 4):
                candidates = indices[np.logical_not(np.isin(indices, built_sol))]
                costs = np.zeros(candidates.shape[0])
                for i in built_sol:
                    for inx in range(0, candidates.shape[0]):
                        costs[inx] += 1/distances[i, candidates[inx]]
                sorted_c = np.argsort(costs)
                candidates = candidates[sorted_c]       
                costs = costs[sorted_c]
                c_min = np.min(costs)
                c_max = np.max(costs)
                filtered_c = costs <= (c_min + alpha * (c_max - c_min))
                costs = costs[filtered_c]
                candidates = candidates[filtered_c]
                choosen = candidates[np.random.randint(0, candidates.shape[0], 1)]
                built_sol = np.append(built_sol, choosen)
            assert built_sol.shape[0] == 4 and np.unique(built_sol).shape[0] == built_sol.shape[0]

            center, radius = find_sphere(points[built_sol[0]], points[built_sol[1]], points[built_sol[2]], points[built_sol[3]])
            current_cost = evaluate_sphere(center, radius, points, directions)
            if use_reference_point:
                current_cost += 100.0 * np.linalg.norm(center - reference_point)
            if current_cost < best_cost and radius <= max_radius:
                best_cost = current_cost
                best_sol = center
                best_sol_inds = built_sol
                print("DatasetColmap: [CONSTR] New best solution found with cost {:.4f}: {}".format(best_cost, best_sol))
        
        # -------------- Local improvement phase -------------- #
        #print("Exploring local neighborhood...")
        for _ in range(0, max_depth):
            shifts = np.unique(np.random.randint(-1, 1, (60, 4)), axis=0)
            neighs = ((np.reshape(np.tile(best_sol_inds, (1, shifts.shape[0])), (shifts.shape[0], 4)) + shifts) + n_points) % n_points
            n_costs = np.zeros(neighs.shape[0])
            for i in range(0, neighs.shape[0]):
                center, radius = find_sphere(points[neighs[i][0]], points[neighs[i][1]], points[neighs[i][2]], points[neighs[i][3]])
                n_costs[i] = evaluate_sphere(center, radius, points, directions)
                if use_reference_point:
                    n_costs[i] += 100.0 * np.linalg.norm(center - reference_point)
            n_sort = np.argsort(n_costs)
            neighs = neighs[n_sort]
            n_costs = n_costs[n_sort]
            if n_costs[0] < best_cost and radius <= max_radius:
                best_cost = n_costs[0]
                best_sol, _ = find_sphere(points[neighs[0][0]], points[neighs[0][1]], points[neighs[0][2]], points[neighs[0][3]])
                best_sol_inds = neighs[0]
                print("DatasetColmap: [SEARCH] New best solution found with cost {:.4f}: {}".format(best_cost, best_sol))
            else:
                #print("No improvements found in local neighborhood")
                if not exhaustive_search:
                    break

    return best_sol

def evaluate_sphere(center, radius, points, directions):
    n_points = points.shape[0]
    dims = points.shape[1]
    mapped_directions = np.reshape(np.tile(center, (1, n_points)), (n_points, dims)) - points
    dists = np.linalg.norm(mapped_directions, axis=-1)
    mapped_directions = mapped_directions / np.tile(dists, (1, mapped_directions.shape[1])).reshape(mapped_directions.shape)
    cosines = np.ones(directions.shape[0]) - np.einsum('ij,ij->i', directions, mapped_directions)
    ca = np.sum(np.abs(dists - radius))
    cb = np.sum(np.abs(cosines))
    current_cost = 0.40 * ca + 1.0 * cb
    return current_cost

def evaluate_sphere_no_radius(center, points, directions):
    points, directions = filter_outliers(points, directions)
    n_points = points.shape[0]
    dims = points.shape[1]
    mapped_directions = np.reshape(np.tile(center, (1, n_points)), (n_points, dims)) - points
    dists = np.linalg.norm(mapped_directions, axis=-1)
    mapped_directions = mapped_directions / np.tile(dists, (1, mapped_directions.shape[1])).reshape(mapped_directions.shape)
    cosines = np.ones(directions.shape[0]) - np.einsum('ij,ij->i', directions, mapped_directions)
    current_cost = np.sum(np.abs(cosines))
    return current_cost